---
title: C++异常安全
date: 2023-01-31 14:57  
tags: [C++,异常]  
source: https://zhuanlan.zhihu.com/p/318741315
---
## 异常安全概念

***异常安全***的意思就是，***当程序在异常发生的时候，程序可以回退的很干净***。什么是回退的很干净呢？其实就是函数在发生异常的时候***不会泄露资源***或者***不会发生任何数据结构的破坏***。如果说一个函数是异常安全的，那么它必须满足上面提到的两个条件。

*异常安全*分为三个级别：

- 基本级别：可能发生异常，且在异常发生的时候代码保证做了任何必要的清理工作，即程序在合法阶段，但是一些数据结构可能已经被函数更改，不一定是调用之前的状态，但是基本是保证符合对象正常的要求的；
- 强烈级别：可能发生异常，且在发生异常时代码保证函数对数据做的任何修改都可以被回滚。即如果调用成功，则完全成功；如果调用失败，则对象依旧是调用之前的状态；
- 无异常：即函数保证不会抛出异常（比如标准库的swap函数等）。

## 异常安全两个反面例子

前面我们说，一个函数如果是异常安全的，那么它必须满足两个条件：

-   一是不泄露任何资源（已申请的资源被正确释放）
-   二是不破坏任何数据结构（无野指针等）

下面我们通过两个反例来说明这两个条件分别表示什么意思：

-   **第一个是造成资源泄漏的例子：**

```C++
void Type::Func()
{
    Lock(&mutex);
    DoSomething();
    UnLock(&mutex);
}
```

上面的代码表示首先获得互斥锁，中间做一些其他事，最后释放互斥锁。我们从异常安全的角度分析，如果*DoSomething()*函数内部出现了异常，那么*UnLock(&mutex)*将不会被执行，互斥锁就永远不会被释放，就造成了资源泄漏。

-   **第二个是造成数据破坏的例子**

假设一个类Type，其中一个成员是指向一块资源的指针，我们通过重载"="操作符来进行说明：

```C++
class Type
{
public:
    Type& operator = (const Type& t)
    {
        if (this == &t)
            return *this;

        else
        {
            delete m_t;
            m_t = new T(t->m_t);
            return *this;
        }
    }

private:
    T* m_t;
};
```

这段代码首先判断是否是自我复制，如果是的话，直接返回this指针指向的对象；如果不是，则首先安全释放当前指向的资源，再创建一块与被复制的对象资源一样的资源并指向它，最后返回复制好的对象。从异常安全的角度分析，一旦*new T(t->m_t)*执行时抛出异常，m_t将指向一块已经被删除的资源，并没有真正指向一块与被复制的对象一样的资源，此时m_t数据遭到了破坏。

## 异常安全解决方案

如果要编写异常安全的代码，我们需要解决上述的两个问题。

-   **资源泄漏问题解决方案**

对于*资源泄漏*问题，解决方案是我们可以用对象来管理资源(即RAII技术，对于指针变量，也可以使用RAII技术进行管理)。我们在函数中不直接对互斥锁进行操作，而是用到一个管理互斥锁的对象MutexLock ml：

```C++
void Type::Func()
{
    MutexLock ml(&mutex);
    DoSomething();
}
```

对象ml在初始化之后，自动对mutex上锁，然后做其他事。最后我们不用负责释放互斥锁，即使在DoSomething()函数中抛出了异常，在退出函数的时候，也会对ml自动调用析构函数，就不用担心互斥锁未被正常释放的问题。

-   **数据破坏问题解决方案**

对于数据破坏问题，一个策略是***copy and swap***。就是：先对原对象作出一个副本，在副本上作必要的修改。如果出现任何异常，原对象仍然能保持不变。

```C++
Type& Type::operator = (const Type& t)
{
    Type tmp(t);
    swap(m_t, tmp->m_t);

    return *this;
}
```

上述函数首先创建一个被复制对象t的副本tmp，此时原对象尚未有任何修改，这样即使申请资源时有异常抛出，也不会影响到原对象。如果创建成功，则通过swap函数对临时对象的资源和原对象资源进行交换，标准库的swap函数承诺不抛出异常，这样原对象将成功便成对象t的复制副本。对于这个函数，我们可以认为其实强烈保证异常安全的。

## 总结

总的来说，为了让代码具有更好的异常安全性，首先是**使用对象来管理资源**，以避免资源的泄漏。其实，通过**copy and swap**方法可以实现强烈保证异常安全。函数提供的异常保证性的最高等级是取决于你实现中调用的各个函数中异常等级性最低的那个。

**解决异常安全的方法:**

-   多使用RAII，使用智能指针来管理内存。由于unwind机制的保证，当异常发生时，函数栈内已构造的局部对象的析构函数会被一一调用，在析构函数内释放资源，也就杜绝了内存泄漏的问题。
-   做好程序设计。特别是异常发生时的回滚机制的正确使用，copy-and-swap是有效的方法。
-   注意需要异常保证的函数内部的调用函数，异常安全等级是以有最低等级异常保证的函数确定的。一个系统即使只有一个函数不是异常安全的，那么系统作为一个整体就不是异常安全的，因为调用那个函数可能发生泄漏资源和恶化数据结构。
-   对于一些需要保证性能的程序，在提供基本的异常安全时，要注意，栈解退机制只是调用析构函数，对于内置类型的操作不会被回滚，所以。像起累加器作用的一些内置类型变量，应该注意在函数成功执行后再进行累加。避免数据结构恶化。重新分配资源给原本已经持有资源的变量，应该先清空释放变量的资源，指针再设置为nullptr，防止资源重新分配过程中抛出异常，导致指针变为野指针的问题。
-   流对象，资源对象，new对象，不应该直接作为参数，一旦抛出异常，就可能会导致严重的问题，函数也许会被错误的执行，资源也许会泄漏。对于函数参数和函数内使用的全局变量，应该保证在进入函数内部是是正常状态。
-   减少全局变量的使用，对包含全局变量的函数做异常安全是比较困难的事情，栈解退也只对局部变量起效果。
-   如果不知道如何处理异常，就不要捕获异常，直接终止比吞掉异常不处理要好
-   保证构造，析构，swap不会失败，要**尽量编写异常安全的构造函数**，因为如果在构造函数里面发生异常，那么因为构造对象没有完成，发生异常后并不会触发析构函数，就会造成内存溢出，所以***尽量少的在构造函数里面申请对象***，一旦发生异常，就会很麻烦。如果在析构函数里面发生异常，程序会直接退出。