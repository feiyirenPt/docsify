---
title: 如何用异常 - 知乎  
date: 2023-01-31 15:25  
tags: [C++]  
source:
    - https://zhuanlan.zhihu.com/p/78884196
    - https://www.zhihu.com/question/418933312/answer/1448981082  
    - https://www.zhihu.com/question/418933312/answer/1450355971  
---

## 何时用异常，何时不用
直到看到[这个视频](https://www.youtube.com/watch?v=UsrHQAzSXkA),
答案不能再清晰了。

![][fig1]

> 一般来说写代码时函数不能足前条件和后条件时抛出异常很合理。但在设计函数时，是扩大前条件，当不满足时抛异常，还是减小前条件，尽量不抛异常？  
> 像返回错误码，或expect一样的接口，可以认为后条件已经包括所有情况，理论上也可以不抛出异常。  
> 从调用方来分析，入参范围应该尽量小，编译时能检查最好；出参应该在保持状态一致的情况下，尽可能范围大，包括一些不完全出错的情况，比如返回空容器，返回哨兵等，从而少抛异常。但不应把出错情况都定义到返回值中，那就把功能接口定义成了检查接口。  
> 部分功能本身就有尝试的情况，那么就可以通过重载，把这种情况从正常的情况中区分处理，返回失败供检查。类似的接口如std::filesystem

有了问题，答案就很明确了。

- 如果函数不能满足前条件，断言失败。不要扩大前条件，增加需要检查的范围。也不要减少前条件，让调用方做过多的准备工作。满足前条件是调用方的责任，是bug，要修。

- 函数的后条件应该包括错误的情况，返回错误码和异常都可以，都满足后条件。通过异常或错误码，把错误情况和正常情况中区分出来。如果抛异常，那么不再需要返回错误码，即可以简单的省去返回值中错误值的部分。有返回错误码又抛异常的函数行为有错误。

- 函数应该总是满足后条件，当且仅当，返回成功时，才可能出现不满足后的情况。这种情况是函数自身的bug，要修。调用方可以放心地断言调用结果满足后条件。

- 这个解释其实倾向于使用异常。因为按这个解析，前条件由调用方保证，必须在调用之前检查参数有效性，错误处理代码会与正常路径混在一起，非常不好看。

[fig1]: https://pic4.zhimg.com/v2-fe4cf1f5f9d297f598a1c0446669178b_b.jpg

--- 
## 写C++何时应该捕捉异常
**绝对不要在每个可能抛异常的地方 try-catch**

很多程序员一开始以为异常是这样用的，写起来很繁琐，所以就很排斥——实际上这是 error codes 错误处理的惯性思维：检查每个返回值、不能遗漏任何一个——而 **exceptions 的设计恰恰是为了把我们从这种繁重的工作中解放出来**。

那么，在什么地方 try-catch 呢？简单来说，**不要在任何地方 try-catch，除非你确定这是必要的**。

**C++ 的异常代表着错误，而且往往是严重的错误**；由于异常会一直向外层代码传递，所以如果没有被 catch，默认结果就是程序退出。这是非常合理的。比如一个代码逻辑错误，在运行时是无法解决的，只有人类才能处理；又比如 bad_alloc，可能由于存在内存泄漏，程序最终 out-of-memory 了。那么在每一处可能抛出 bad_alloc 的地方 try-catch 又能做什么呢？其实什么也做不了。我们能做的，就是记录下这次异常，生成 dump 信息，方便 debug。

**有时候异常是可恢复的**，不至于让程序直接退出，那么**只要在能恢复它的那一层逻辑中 try-catch 就可以了**。例如，一个简单的文件处理过程：

```cpp
void foo(const std::vector<std::string>& files)
{
    for (size_t i = 0; i < files.size(); ++i)
    {
        try
        {
            process_file(files[i]);
        }
        catch (parse_error& e)
        {
            // do something
        }
        catch (io_error& e)
        {
            // do something
        }
        catch (...)
        {
            // do something
        }
    }
}
```

foo 会遍历列表中的每一个文件，并调用 process_file 进行处理。process_file 非常复杂，其内部调用了一千多个可能抛出异常的函数，而它都没有 try-catch，所以这些异常会从 process_file 抛出来。在 foo 这层，我们只关心文件处理本身；如果一个文件处理失败了，无论原因是什么，我们都尝试处理下一个文件。最终，假设有 5 个文件处理失败了，可能是文件过大导致无法载入内存引起 bad_alloc，可能是文件格式错误，也可能是 IO 错误——这些问题在运行时无法解决，但好在我们成功了 995 个，而不是让程序中止在某个错误的文件上。

所以，看，**异常错误处理就是多数时候不作处理。**当然，同时我们还应该写异常安全的代码，包括应用 shared_ptr 以及 RAII 等技巧；否则上面的 process_file 每失败一次就泄漏大量内存，或是让程序出现错误的状态，那就真的没救了。

---
在有对策处 catch。

比如到了必须转换错误报告方法的地方：这个函数往上就不接受异常了（这个函数是个 C 接口、系统回调、noexcept 函数之类的），那么在这个函数里 function try，根据异常信息返回不同的错误码。

比如 HTTP 服务器处理请求时，常见的对策是对任何异常都记录日志并向客户端返回状态码为 500 的响应。那么我们要做的就是把所有处理请求的代码 try 起来，catch 所有异常并处理。无所谓它是 MyCustomException 还是 std::bad_alloc。

确有备用方案的时候也可以 catch：比如加载文本的时候 UTF-8 解码抛出异常发现不合法的字节，我们可以 catch 住去尝试 GBK 解码。

本质上就是看需求来定，而不是看程序代码来定。

我在 Photoshop 里点击打开文件按钮尝试打开一个需要 1T 内存才能打开的图片，我的机器无法分配这么多内存，所以底层抛出了 std::bad_alloc 异常。此时 Photoshop 并不只能在「假装分配成功了继续往下执行」和「由着它崩溃」之间二选一。他还可以捕获下来弹个对话框提示「内存不足无法打开」。

异常处理并不等于「消除异常产生的原因，让程序能和没发生过异常一样继续往下执行」，就像我们应该解决问题，而不是解决提出问题的人一样。
